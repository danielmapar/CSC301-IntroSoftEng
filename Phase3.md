##### Why things went right with design

We came up with an initial design for the layout of the screens and interactions between them that would satisfy the requirements of our MVP. After starting the implementation, multiple revisions to the front-end design were made until we had a streamlined flow through app/website. Another thing that went well for us was that we have frequent, small meetings. This helped our group solidify our goals, clear up confusions, and stay focused. Also, since every person was responsible for a specific module that they had total ownership over, everyone was working on what they were comfortable with (Nick/Sandy/Haris/Tony on front-end, Daniel on Django set up, Chandeep on Chat API tinkering, Adam on database).
We also rehearsed for our demo, so that prepared us well.

##### Why are you changing your design / Why are you not changing your design

In terms of back-end design, we already underwent design revisions while developing the product. Specifically, we changed our database schema half way through development to accommodate the specific needs of our demo. Also, due to the lack of knowledge in Django, we wasted some time implementing database models, but later rcealized that Django has the ability to do this automatically. 
For the next phase, we will probably be implementing a very slight design change into the database models. Currently, the possible user interest fields (books, video games, music) are all hard coded. This is not ideal because if we want to add interests we have to edit the code. Instead, we plan to read these interests dynamically from the database, and have them populated for the user to view. This way, all we need to do to add a new interest is edit the database and the back-end will automatically pull it in.

In terms of front-end design, we plan on overhauling the look of our user interface. Specifically, we will need to design a cohesive artstyle for the app so that the experience of navigating through it is simple, and visually pleasing. We are also toying with the idea of changing how certain user interface elements like the navbar work, so that we can achieve a better layout on mobile devices by utilizing the built-in responsive design features of Twitter Bootstrap. For example, we might change the static navbar to a drop down menu which not only reduces clutter but ensures better scaling to mobile devices. We also need to implement the page in which our users will chat in. This has not yet been implemented since our primary focus was on the matching component for phase one. While this is not exactly a design change, since we have a sketch for the chat page implemented, we still anticipate that revisions to the design will need to be made since we have to accommodate for the API and other requirements of the QuickBlox chat framework we are using.

There is also much of our front-end design that we do not plan on changing. And this is because we made several good decisions in developing the user interface that worked well. Firstly, we decided in our preliminary meeting that we would use the Twitter Bootstrap front-end framework. This reduced the amount of work we would need to do by handling menial layout concerns, and making the user interface look more presentable right off the bat. Secondly, we held a meetings between the front-end developers to draw up a detailed design for the user interface that we all agreed on, and revised together. It was especially important to us that we nailed the design early on specifically to avoid the pains of major revisions later on after code had already been written. Thirdly, we divided the the front-end work in a clever way. We assigned specific pages to each front-end dev to avoid usability and visual clashes on the same page that would happen naturally from having two people working on the same page.

However, we did have a couple of issues with the front-end design. First, since the Bootstrap framework was new, we soon realized after some prototypes that we weren’t implementing it properly and as a result we had some minor HTML rendering issues, as well as a non-responsive design. So for the next phase we will be looking to correct these issues, and the goal is to have a nice looking design that is fully responsive all the way from mobile to full desktop.

On the back-end side of things we had some issues as well. The team suffered from a lack of Django familiarity as Daniel was our only experienced Django developer. Some of us had experience with other web frameworks like Ruby on Rails, but we decided on Django since we all have Python experience from CSC108. A specific issue that rose from our Django inexperience was that we wasted some time creating models for the database schema, but it turned out that Django created these automatically.

We also had some unique team availability problems that were completely unavoidable. Daniel had some serious medical issues that he needed to take care of, and Adam had a commitment in Europe at a prestigious World of Tanks e-sports tournament. We also had some members who were sick with flu-like symptoms for quite a while. Still, we managed to work together very effectively and efficiently, all things considered.

Finally, our greatest issues was probably the fact that we did not utilize branching very efficiently for this phase. Each member did not make a personal branch off of develop for their parts of the assignment. Additionally, for some time, the master branch was ahead of develop (which it should never be). So we ended up with a really messy Git tree, and had to fix everything after the phase was done. I think this also happened because we didn’t use the Github issue management system properly, thus didn’t know how to branch things. In the next phase we plan to delegate all tasks through the issue management system, and this way we can have a branch corresponding to each of these issues/tasks.

##### Design Patterns

Since we used Django for the back-end, a lot of our project utilizes the model-view-controller (MVC) design pattern. Since our group was split into two groups one, for front-end and one for back-end, the MVC design pattern was also ideal for us to use because if we had some people working on models, some on view, and some on controller, it would be easy to separate the work and put it together in the end.  Django also provides a DAO implementation of database interaction; to change databases, we just change one settings file and run a script.  


